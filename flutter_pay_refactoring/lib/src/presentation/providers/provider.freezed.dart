// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'provider.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$HomePointState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(DioException exception) failure,
    required TResult Function() success,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(DioException exception)? failure,
    TResult? Function()? success,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(DioException exception)? failure,
    TResult Function()? success,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(HomePointStateInitial value) initial,
    required TResult Function(HomePointStateLoading value) loading,
    required TResult Function(HomePointStateFailure value) failure,
    required TResult Function(HomePointStateSuccess value) success,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(HomePointStateInitial value)? initial,
    TResult? Function(HomePointStateLoading value)? loading,
    TResult? Function(HomePointStateFailure value)? failure,
    TResult? Function(HomePointStateSuccess value)? success,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(HomePointStateInitial value)? initial,
    TResult Function(HomePointStateLoading value)? loading,
    TResult Function(HomePointStateFailure value)? failure,
    TResult Function(HomePointStateSuccess value)? success,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $HomePointStateCopyWith<$Res> {
  factory $HomePointStateCopyWith(
          HomePointState value, $Res Function(HomePointState) then) =
      _$HomePointStateCopyWithImpl<$Res, HomePointState>;
}

/// @nodoc
class _$HomePointStateCopyWithImpl<$Res, $Val extends HomePointState>
    implements $HomePointStateCopyWith<$Res> {
  _$HomePointStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$HomePointStateInitialImplCopyWith<$Res> {
  factory _$$HomePointStateInitialImplCopyWith(
          _$HomePointStateInitialImpl value,
          $Res Function(_$HomePointStateInitialImpl) then) =
      __$$HomePointStateInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$HomePointStateInitialImplCopyWithImpl<$Res>
    extends _$HomePointStateCopyWithImpl<$Res, _$HomePointStateInitialImpl>
    implements _$$HomePointStateInitialImplCopyWith<$Res> {
  __$$HomePointStateInitialImplCopyWithImpl(_$HomePointStateInitialImpl _value,
      $Res Function(_$HomePointStateInitialImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$HomePointStateInitialImpl implements HomePointStateInitial {
  const _$HomePointStateInitialImpl();

  @override
  String toString() {
    return 'HomePointState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$HomePointStateInitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(DioException exception) failure,
    required TResult Function() success,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(DioException exception)? failure,
    TResult? Function()? success,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(DioException exception)? failure,
    TResult Function()? success,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(HomePointStateInitial value) initial,
    required TResult Function(HomePointStateLoading value) loading,
    required TResult Function(HomePointStateFailure value) failure,
    required TResult Function(HomePointStateSuccess value) success,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(HomePointStateInitial value)? initial,
    TResult? Function(HomePointStateLoading value)? loading,
    TResult? Function(HomePointStateFailure value)? failure,
    TResult? Function(HomePointStateSuccess value)? success,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(HomePointStateInitial value)? initial,
    TResult Function(HomePointStateLoading value)? loading,
    TResult Function(HomePointStateFailure value)? failure,
    TResult Function(HomePointStateSuccess value)? success,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class HomePointStateInitial implements HomePointState {
  const factory HomePointStateInitial() = _$HomePointStateInitialImpl;
}

/// @nodoc
abstract class _$$HomePointStateLoadingImplCopyWith<$Res> {
  factory _$$HomePointStateLoadingImplCopyWith(
          _$HomePointStateLoadingImpl value,
          $Res Function(_$HomePointStateLoadingImpl) then) =
      __$$HomePointStateLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$HomePointStateLoadingImplCopyWithImpl<$Res>
    extends _$HomePointStateCopyWithImpl<$Res, _$HomePointStateLoadingImpl>
    implements _$$HomePointStateLoadingImplCopyWith<$Res> {
  __$$HomePointStateLoadingImplCopyWithImpl(_$HomePointStateLoadingImpl _value,
      $Res Function(_$HomePointStateLoadingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$HomePointStateLoadingImpl implements HomePointStateLoading {
  const _$HomePointStateLoadingImpl();

  @override
  String toString() {
    return 'HomePointState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$HomePointStateLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(DioException exception) failure,
    required TResult Function() success,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(DioException exception)? failure,
    TResult? Function()? success,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(DioException exception)? failure,
    TResult Function()? success,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(HomePointStateInitial value) initial,
    required TResult Function(HomePointStateLoading value) loading,
    required TResult Function(HomePointStateFailure value) failure,
    required TResult Function(HomePointStateSuccess value) success,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(HomePointStateInitial value)? initial,
    TResult? Function(HomePointStateLoading value)? loading,
    TResult? Function(HomePointStateFailure value)? failure,
    TResult? Function(HomePointStateSuccess value)? success,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(HomePointStateInitial value)? initial,
    TResult Function(HomePointStateLoading value)? loading,
    TResult Function(HomePointStateFailure value)? failure,
    TResult Function(HomePointStateSuccess value)? success,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class HomePointStateLoading implements HomePointState {
  const factory HomePointStateLoading() = _$HomePointStateLoadingImpl;
}

/// @nodoc
abstract class _$$HomePointStateFailureImplCopyWith<$Res> {
  factory _$$HomePointStateFailureImplCopyWith(
          _$HomePointStateFailureImpl value,
          $Res Function(_$HomePointStateFailureImpl) then) =
      __$$HomePointStateFailureImplCopyWithImpl<$Res>;
  @useResult
  $Res call({DioException exception});
}

/// @nodoc
class __$$HomePointStateFailureImplCopyWithImpl<$Res>
    extends _$HomePointStateCopyWithImpl<$Res, _$HomePointStateFailureImpl>
    implements _$$HomePointStateFailureImplCopyWith<$Res> {
  __$$HomePointStateFailureImplCopyWithImpl(_$HomePointStateFailureImpl _value,
      $Res Function(_$HomePointStateFailureImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? exception = null,
  }) {
    return _then(_$HomePointStateFailureImpl(
      null == exception
          ? _value.exception
          : exception // ignore: cast_nullable_to_non_nullable
              as DioException,
    ));
  }
}

/// @nodoc

class _$HomePointStateFailureImpl implements HomePointStateFailure {
  const _$HomePointStateFailureImpl(this.exception);

  @override
  final DioException exception;

  @override
  String toString() {
    return 'HomePointState.failure(exception: $exception)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$HomePointStateFailureImpl &&
            (identical(other.exception, exception) ||
                other.exception == exception));
  }

  @override
  int get hashCode => Object.hash(runtimeType, exception);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$HomePointStateFailureImplCopyWith<_$HomePointStateFailureImpl>
      get copyWith => __$$HomePointStateFailureImplCopyWithImpl<
          _$HomePointStateFailureImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(DioException exception) failure,
    required TResult Function() success,
  }) {
    return failure(exception);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(DioException exception)? failure,
    TResult? Function()? success,
  }) {
    return failure?.call(exception);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(DioException exception)? failure,
    TResult Function()? success,
    required TResult orElse(),
  }) {
    if (failure != null) {
      return failure(exception);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(HomePointStateInitial value) initial,
    required TResult Function(HomePointStateLoading value) loading,
    required TResult Function(HomePointStateFailure value) failure,
    required TResult Function(HomePointStateSuccess value) success,
  }) {
    return failure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(HomePointStateInitial value)? initial,
    TResult? Function(HomePointStateLoading value)? loading,
    TResult? Function(HomePointStateFailure value)? failure,
    TResult? Function(HomePointStateSuccess value)? success,
  }) {
    return failure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(HomePointStateInitial value)? initial,
    TResult Function(HomePointStateLoading value)? loading,
    TResult Function(HomePointStateFailure value)? failure,
    TResult Function(HomePointStateSuccess value)? success,
    required TResult orElse(),
  }) {
    if (failure != null) {
      return failure(this);
    }
    return orElse();
  }
}

abstract class HomePointStateFailure implements HomePointState {
  const factory HomePointStateFailure(final DioException exception) =
      _$HomePointStateFailureImpl;

  DioException get exception;
  @JsonKey(ignore: true)
  _$$HomePointStateFailureImplCopyWith<_$HomePointStateFailureImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$HomePointStateSuccessImplCopyWith<$Res> {
  factory _$$HomePointStateSuccessImplCopyWith(
          _$HomePointStateSuccessImpl value,
          $Res Function(_$HomePointStateSuccessImpl) then) =
      __$$HomePointStateSuccessImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$HomePointStateSuccessImplCopyWithImpl<$Res>
    extends _$HomePointStateCopyWithImpl<$Res, _$HomePointStateSuccessImpl>
    implements _$$HomePointStateSuccessImplCopyWith<$Res> {
  __$$HomePointStateSuccessImplCopyWithImpl(_$HomePointStateSuccessImpl _value,
      $Res Function(_$HomePointStateSuccessImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$HomePointStateSuccessImpl implements HomePointStateSuccess {
  const _$HomePointStateSuccessImpl();

  @override
  String toString() {
    return 'HomePointState.success()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$HomePointStateSuccessImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(DioException exception) failure,
    required TResult Function() success,
  }) {
    return success();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(DioException exception)? failure,
    TResult? Function()? success,
  }) {
    return success?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(DioException exception)? failure,
    TResult Function()? success,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(HomePointStateInitial value) initial,
    required TResult Function(HomePointStateLoading value) loading,
    required TResult Function(HomePointStateFailure value) failure,
    required TResult Function(HomePointStateSuccess value) success,
  }) {
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(HomePointStateInitial value)? initial,
    TResult? Function(HomePointStateLoading value)? loading,
    TResult? Function(HomePointStateFailure value)? failure,
    TResult? Function(HomePointStateSuccess value)? success,
  }) {
    return success?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(HomePointStateInitial value)? initial,
    TResult Function(HomePointStateLoading value)? loading,
    TResult Function(HomePointStateFailure value)? failure,
    TResult Function(HomePointStateSuccess value)? success,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(this);
    }
    return orElse();
  }
}

abstract class HomePointStateSuccess implements HomePointState {
  const factory HomePointStateSuccess() = _$HomePointStateSuccessImpl;
}

/// @nodoc
mixin _$HistoryState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() failure,
    required TResult Function() empty,
    required TResult Function() success,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? failure,
    TResult? Function()? empty,
    TResult? Function()? success,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? failure,
    TResult Function()? empty,
    TResult Function()? success,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(HistoryStateInitial value) initial,
    required TResult Function(HistoryStateLoading value) loading,
    required TResult Function(HistoryStateFailure value) failure,
    required TResult Function(HistoryStateEmpty value) empty,
    required TResult Function(HistoryStateSuccess value) success,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(HistoryStateInitial value)? initial,
    TResult? Function(HistoryStateLoading value)? loading,
    TResult? Function(HistoryStateFailure value)? failure,
    TResult? Function(HistoryStateEmpty value)? empty,
    TResult? Function(HistoryStateSuccess value)? success,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(HistoryStateInitial value)? initial,
    TResult Function(HistoryStateLoading value)? loading,
    TResult Function(HistoryStateFailure value)? failure,
    TResult Function(HistoryStateEmpty value)? empty,
    TResult Function(HistoryStateSuccess value)? success,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $HistoryStateCopyWith<$Res> {
  factory $HistoryStateCopyWith(
          HistoryState value, $Res Function(HistoryState) then) =
      _$HistoryStateCopyWithImpl<$Res, HistoryState>;
}

/// @nodoc
class _$HistoryStateCopyWithImpl<$Res, $Val extends HistoryState>
    implements $HistoryStateCopyWith<$Res> {
  _$HistoryStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$HistoryStateInitialImplCopyWith<$Res> {
  factory _$$HistoryStateInitialImplCopyWith(_$HistoryStateInitialImpl value,
          $Res Function(_$HistoryStateInitialImpl) then) =
      __$$HistoryStateInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$HistoryStateInitialImplCopyWithImpl<$Res>
    extends _$HistoryStateCopyWithImpl<$Res, _$HistoryStateInitialImpl>
    implements _$$HistoryStateInitialImplCopyWith<$Res> {
  __$$HistoryStateInitialImplCopyWithImpl(_$HistoryStateInitialImpl _value,
      $Res Function(_$HistoryStateInitialImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$HistoryStateInitialImpl implements HistoryStateInitial {
  const _$HistoryStateInitialImpl();

  @override
  String toString() {
    return 'HistoryState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$HistoryStateInitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() failure,
    required TResult Function() empty,
    required TResult Function() success,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? failure,
    TResult? Function()? empty,
    TResult? Function()? success,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? failure,
    TResult Function()? empty,
    TResult Function()? success,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(HistoryStateInitial value) initial,
    required TResult Function(HistoryStateLoading value) loading,
    required TResult Function(HistoryStateFailure value) failure,
    required TResult Function(HistoryStateEmpty value) empty,
    required TResult Function(HistoryStateSuccess value) success,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(HistoryStateInitial value)? initial,
    TResult? Function(HistoryStateLoading value)? loading,
    TResult? Function(HistoryStateFailure value)? failure,
    TResult? Function(HistoryStateEmpty value)? empty,
    TResult? Function(HistoryStateSuccess value)? success,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(HistoryStateInitial value)? initial,
    TResult Function(HistoryStateLoading value)? loading,
    TResult Function(HistoryStateFailure value)? failure,
    TResult Function(HistoryStateEmpty value)? empty,
    TResult Function(HistoryStateSuccess value)? success,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class HistoryStateInitial implements HistoryState {
  const factory HistoryStateInitial() = _$HistoryStateInitialImpl;
}

/// @nodoc
abstract class _$$HistoryStateLoadingImplCopyWith<$Res> {
  factory _$$HistoryStateLoadingImplCopyWith(_$HistoryStateLoadingImpl value,
          $Res Function(_$HistoryStateLoadingImpl) then) =
      __$$HistoryStateLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$HistoryStateLoadingImplCopyWithImpl<$Res>
    extends _$HistoryStateCopyWithImpl<$Res, _$HistoryStateLoadingImpl>
    implements _$$HistoryStateLoadingImplCopyWith<$Res> {
  __$$HistoryStateLoadingImplCopyWithImpl(_$HistoryStateLoadingImpl _value,
      $Res Function(_$HistoryStateLoadingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$HistoryStateLoadingImpl implements HistoryStateLoading {
  const _$HistoryStateLoadingImpl();

  @override
  String toString() {
    return 'HistoryState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$HistoryStateLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() failure,
    required TResult Function() empty,
    required TResult Function() success,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? failure,
    TResult? Function()? empty,
    TResult? Function()? success,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? failure,
    TResult Function()? empty,
    TResult Function()? success,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(HistoryStateInitial value) initial,
    required TResult Function(HistoryStateLoading value) loading,
    required TResult Function(HistoryStateFailure value) failure,
    required TResult Function(HistoryStateEmpty value) empty,
    required TResult Function(HistoryStateSuccess value) success,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(HistoryStateInitial value)? initial,
    TResult? Function(HistoryStateLoading value)? loading,
    TResult? Function(HistoryStateFailure value)? failure,
    TResult? Function(HistoryStateEmpty value)? empty,
    TResult? Function(HistoryStateSuccess value)? success,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(HistoryStateInitial value)? initial,
    TResult Function(HistoryStateLoading value)? loading,
    TResult Function(HistoryStateFailure value)? failure,
    TResult Function(HistoryStateEmpty value)? empty,
    TResult Function(HistoryStateSuccess value)? success,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class HistoryStateLoading implements HistoryState {
  const factory HistoryStateLoading() = _$HistoryStateLoadingImpl;
}

/// @nodoc
abstract class _$$HistoryStateFailureImplCopyWith<$Res> {
  factory _$$HistoryStateFailureImplCopyWith(_$HistoryStateFailureImpl value,
          $Res Function(_$HistoryStateFailureImpl) then) =
      __$$HistoryStateFailureImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$HistoryStateFailureImplCopyWithImpl<$Res>
    extends _$HistoryStateCopyWithImpl<$Res, _$HistoryStateFailureImpl>
    implements _$$HistoryStateFailureImplCopyWith<$Res> {
  __$$HistoryStateFailureImplCopyWithImpl(_$HistoryStateFailureImpl _value,
      $Res Function(_$HistoryStateFailureImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$HistoryStateFailureImpl implements HistoryStateFailure {
  const _$HistoryStateFailureImpl();

  @override
  String toString() {
    return 'HistoryState.failure()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$HistoryStateFailureImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() failure,
    required TResult Function() empty,
    required TResult Function() success,
  }) {
    return failure();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? failure,
    TResult? Function()? empty,
    TResult? Function()? success,
  }) {
    return failure?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? failure,
    TResult Function()? empty,
    TResult Function()? success,
    required TResult orElse(),
  }) {
    if (failure != null) {
      return failure();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(HistoryStateInitial value) initial,
    required TResult Function(HistoryStateLoading value) loading,
    required TResult Function(HistoryStateFailure value) failure,
    required TResult Function(HistoryStateEmpty value) empty,
    required TResult Function(HistoryStateSuccess value) success,
  }) {
    return failure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(HistoryStateInitial value)? initial,
    TResult? Function(HistoryStateLoading value)? loading,
    TResult? Function(HistoryStateFailure value)? failure,
    TResult? Function(HistoryStateEmpty value)? empty,
    TResult? Function(HistoryStateSuccess value)? success,
  }) {
    return failure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(HistoryStateInitial value)? initial,
    TResult Function(HistoryStateLoading value)? loading,
    TResult Function(HistoryStateFailure value)? failure,
    TResult Function(HistoryStateEmpty value)? empty,
    TResult Function(HistoryStateSuccess value)? success,
    required TResult orElse(),
  }) {
    if (failure != null) {
      return failure(this);
    }
    return orElse();
  }
}

abstract class HistoryStateFailure implements HistoryState {
  const factory HistoryStateFailure() = _$HistoryStateFailureImpl;
}

/// @nodoc
abstract class _$$HistoryStateEmptyImplCopyWith<$Res> {
  factory _$$HistoryStateEmptyImplCopyWith(_$HistoryStateEmptyImpl value,
          $Res Function(_$HistoryStateEmptyImpl) then) =
      __$$HistoryStateEmptyImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$HistoryStateEmptyImplCopyWithImpl<$Res>
    extends _$HistoryStateCopyWithImpl<$Res, _$HistoryStateEmptyImpl>
    implements _$$HistoryStateEmptyImplCopyWith<$Res> {
  __$$HistoryStateEmptyImplCopyWithImpl(_$HistoryStateEmptyImpl _value,
      $Res Function(_$HistoryStateEmptyImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$HistoryStateEmptyImpl implements HistoryStateEmpty {
  const _$HistoryStateEmptyImpl();

  @override
  String toString() {
    return 'HistoryState.empty()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$HistoryStateEmptyImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() failure,
    required TResult Function() empty,
    required TResult Function() success,
  }) {
    return empty();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? failure,
    TResult? Function()? empty,
    TResult? Function()? success,
  }) {
    return empty?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? failure,
    TResult Function()? empty,
    TResult Function()? success,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(HistoryStateInitial value) initial,
    required TResult Function(HistoryStateLoading value) loading,
    required TResult Function(HistoryStateFailure value) failure,
    required TResult Function(HistoryStateEmpty value) empty,
    required TResult Function(HistoryStateSuccess value) success,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(HistoryStateInitial value)? initial,
    TResult? Function(HistoryStateLoading value)? loading,
    TResult? Function(HistoryStateFailure value)? failure,
    TResult? Function(HistoryStateEmpty value)? empty,
    TResult? Function(HistoryStateSuccess value)? success,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(HistoryStateInitial value)? initial,
    TResult Function(HistoryStateLoading value)? loading,
    TResult Function(HistoryStateFailure value)? failure,
    TResult Function(HistoryStateEmpty value)? empty,
    TResult Function(HistoryStateSuccess value)? success,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class HistoryStateEmpty implements HistoryState {
  const factory HistoryStateEmpty() = _$HistoryStateEmptyImpl;
}

/// @nodoc
abstract class _$$HistoryStateSuccessImplCopyWith<$Res> {
  factory _$$HistoryStateSuccessImplCopyWith(_$HistoryStateSuccessImpl value,
          $Res Function(_$HistoryStateSuccessImpl) then) =
      __$$HistoryStateSuccessImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$HistoryStateSuccessImplCopyWithImpl<$Res>
    extends _$HistoryStateCopyWithImpl<$Res, _$HistoryStateSuccessImpl>
    implements _$$HistoryStateSuccessImplCopyWith<$Res> {
  __$$HistoryStateSuccessImplCopyWithImpl(_$HistoryStateSuccessImpl _value,
      $Res Function(_$HistoryStateSuccessImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$HistoryStateSuccessImpl implements HistoryStateSuccess {
  const _$HistoryStateSuccessImpl();

  @override
  String toString() {
    return 'HistoryState.success()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$HistoryStateSuccessImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() failure,
    required TResult Function() empty,
    required TResult Function() success,
  }) {
    return success();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? failure,
    TResult? Function()? empty,
    TResult? Function()? success,
  }) {
    return success?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? failure,
    TResult Function()? empty,
    TResult Function()? success,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(HistoryStateInitial value) initial,
    required TResult Function(HistoryStateLoading value) loading,
    required TResult Function(HistoryStateFailure value) failure,
    required TResult Function(HistoryStateEmpty value) empty,
    required TResult Function(HistoryStateSuccess value) success,
  }) {
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(HistoryStateInitial value)? initial,
    TResult? Function(HistoryStateLoading value)? loading,
    TResult? Function(HistoryStateFailure value)? failure,
    TResult? Function(HistoryStateEmpty value)? empty,
    TResult? Function(HistoryStateSuccess value)? success,
  }) {
    return success?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(HistoryStateInitial value)? initial,
    TResult Function(HistoryStateLoading value)? loading,
    TResult Function(HistoryStateFailure value)? failure,
    TResult Function(HistoryStateEmpty value)? empty,
    TResult Function(HistoryStateSuccess value)? success,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(this);
    }
    return orElse();
  }
}

abstract class HistoryStateSuccess implements HistoryState {
  const factory HistoryStateSuccess() = _$HistoryStateSuccessImpl;
}

PaymentState _$PaymentStateFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'initial':
      return PaymentInitial.fromJson(json);
    case 'loading':
      return PaymentLoading.fromJson(json);
    case 'failure':
      return PaymentFailure.fromJson(json);
    case 'success':
      return PaymentSuccess.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'PaymentState',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$PaymentState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() failure,
    required TResult Function() success,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? failure,
    TResult? Function()? success,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? failure,
    TResult Function()? success,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PaymentInitial value) initial,
    required TResult Function(PaymentLoading value) loading,
    required TResult Function(PaymentFailure value) failure,
    required TResult Function(PaymentSuccess value) success,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PaymentInitial value)? initial,
    TResult? Function(PaymentLoading value)? loading,
    TResult? Function(PaymentFailure value)? failure,
    TResult? Function(PaymentSuccess value)? success,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PaymentInitial value)? initial,
    TResult Function(PaymentLoading value)? loading,
    TResult Function(PaymentFailure value)? failure,
    TResult Function(PaymentSuccess value)? success,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PaymentStateCopyWith<$Res> {
  factory $PaymentStateCopyWith(
          PaymentState value, $Res Function(PaymentState) then) =
      _$PaymentStateCopyWithImpl<$Res, PaymentState>;
}

/// @nodoc
class _$PaymentStateCopyWithImpl<$Res, $Val extends PaymentState>
    implements $PaymentStateCopyWith<$Res> {
  _$PaymentStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$PaymentInitialImplCopyWith<$Res> {
  factory _$$PaymentInitialImplCopyWith(_$PaymentInitialImpl value,
          $Res Function(_$PaymentInitialImpl) then) =
      __$$PaymentInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PaymentInitialImplCopyWithImpl<$Res>
    extends _$PaymentStateCopyWithImpl<$Res, _$PaymentInitialImpl>
    implements _$$PaymentInitialImplCopyWith<$Res> {
  __$$PaymentInitialImplCopyWithImpl(
      _$PaymentInitialImpl _value, $Res Function(_$PaymentInitialImpl) _then)
      : super(_value, _then);
}

/// @nodoc
@JsonSerializable()
class _$PaymentInitialImpl implements PaymentInitial {
  const _$PaymentInitialImpl({final String? $type})
      : $type = $type ?? 'initial';

  factory _$PaymentInitialImpl.fromJson(Map<String, dynamic> json) =>
      _$$PaymentInitialImplFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'PaymentState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PaymentInitialImpl);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() failure,
    required TResult Function() success,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? failure,
    TResult? Function()? success,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? failure,
    TResult Function()? success,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PaymentInitial value) initial,
    required TResult Function(PaymentLoading value) loading,
    required TResult Function(PaymentFailure value) failure,
    required TResult Function(PaymentSuccess value) success,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PaymentInitial value)? initial,
    TResult? Function(PaymentLoading value)? loading,
    TResult? Function(PaymentFailure value)? failure,
    TResult? Function(PaymentSuccess value)? success,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PaymentInitial value)? initial,
    TResult Function(PaymentLoading value)? loading,
    TResult Function(PaymentFailure value)? failure,
    TResult Function(PaymentSuccess value)? success,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$PaymentInitialImplToJson(
      this,
    );
  }
}

abstract class PaymentInitial implements PaymentState {
  const factory PaymentInitial() = _$PaymentInitialImpl;

  factory PaymentInitial.fromJson(Map<String, dynamic> json) =
      _$PaymentInitialImpl.fromJson;
}

/// @nodoc
abstract class _$$PaymentLoadingImplCopyWith<$Res> {
  factory _$$PaymentLoadingImplCopyWith(_$PaymentLoadingImpl value,
          $Res Function(_$PaymentLoadingImpl) then) =
      __$$PaymentLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PaymentLoadingImplCopyWithImpl<$Res>
    extends _$PaymentStateCopyWithImpl<$Res, _$PaymentLoadingImpl>
    implements _$$PaymentLoadingImplCopyWith<$Res> {
  __$$PaymentLoadingImplCopyWithImpl(
      _$PaymentLoadingImpl _value, $Res Function(_$PaymentLoadingImpl) _then)
      : super(_value, _then);
}

/// @nodoc
@JsonSerializable()
class _$PaymentLoadingImpl implements PaymentLoading {
  const _$PaymentLoadingImpl({final String? $type})
      : $type = $type ?? 'loading';

  factory _$PaymentLoadingImpl.fromJson(Map<String, dynamic> json) =>
      _$$PaymentLoadingImplFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'PaymentState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PaymentLoadingImpl);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() failure,
    required TResult Function() success,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? failure,
    TResult? Function()? success,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? failure,
    TResult Function()? success,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PaymentInitial value) initial,
    required TResult Function(PaymentLoading value) loading,
    required TResult Function(PaymentFailure value) failure,
    required TResult Function(PaymentSuccess value) success,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PaymentInitial value)? initial,
    TResult? Function(PaymentLoading value)? loading,
    TResult? Function(PaymentFailure value)? failure,
    TResult? Function(PaymentSuccess value)? success,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PaymentInitial value)? initial,
    TResult Function(PaymentLoading value)? loading,
    TResult Function(PaymentFailure value)? failure,
    TResult Function(PaymentSuccess value)? success,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$PaymentLoadingImplToJson(
      this,
    );
  }
}

abstract class PaymentLoading implements PaymentState {
  const factory PaymentLoading() = _$PaymentLoadingImpl;

  factory PaymentLoading.fromJson(Map<String, dynamic> json) =
      _$PaymentLoadingImpl.fromJson;
}

/// @nodoc
abstract class _$$PaymentFailureImplCopyWith<$Res> {
  factory _$$PaymentFailureImplCopyWith(_$PaymentFailureImpl value,
          $Res Function(_$PaymentFailureImpl) then) =
      __$$PaymentFailureImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PaymentFailureImplCopyWithImpl<$Res>
    extends _$PaymentStateCopyWithImpl<$Res, _$PaymentFailureImpl>
    implements _$$PaymentFailureImplCopyWith<$Res> {
  __$$PaymentFailureImplCopyWithImpl(
      _$PaymentFailureImpl _value, $Res Function(_$PaymentFailureImpl) _then)
      : super(_value, _then);
}

/// @nodoc
@JsonSerializable()
class _$PaymentFailureImpl implements PaymentFailure {
  const _$PaymentFailureImpl({final String? $type})
      : $type = $type ?? 'failure';

  factory _$PaymentFailureImpl.fromJson(Map<String, dynamic> json) =>
      _$$PaymentFailureImplFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'PaymentState.failure()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PaymentFailureImpl);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() failure,
    required TResult Function() success,
  }) {
    return failure();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? failure,
    TResult? Function()? success,
  }) {
    return failure?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? failure,
    TResult Function()? success,
    required TResult orElse(),
  }) {
    if (failure != null) {
      return failure();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PaymentInitial value) initial,
    required TResult Function(PaymentLoading value) loading,
    required TResult Function(PaymentFailure value) failure,
    required TResult Function(PaymentSuccess value) success,
  }) {
    return failure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PaymentInitial value)? initial,
    TResult? Function(PaymentLoading value)? loading,
    TResult? Function(PaymentFailure value)? failure,
    TResult? Function(PaymentSuccess value)? success,
  }) {
    return failure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PaymentInitial value)? initial,
    TResult Function(PaymentLoading value)? loading,
    TResult Function(PaymentFailure value)? failure,
    TResult Function(PaymentSuccess value)? success,
    required TResult orElse(),
  }) {
    if (failure != null) {
      return failure(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$PaymentFailureImplToJson(
      this,
    );
  }
}

abstract class PaymentFailure implements PaymentState {
  const factory PaymentFailure() = _$PaymentFailureImpl;

  factory PaymentFailure.fromJson(Map<String, dynamic> json) =
      _$PaymentFailureImpl.fromJson;
}

/// @nodoc
abstract class _$$PaymentSuccessImplCopyWith<$Res> {
  factory _$$PaymentSuccessImplCopyWith(_$PaymentSuccessImpl value,
          $Res Function(_$PaymentSuccessImpl) then) =
      __$$PaymentSuccessImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PaymentSuccessImplCopyWithImpl<$Res>
    extends _$PaymentStateCopyWithImpl<$Res, _$PaymentSuccessImpl>
    implements _$$PaymentSuccessImplCopyWith<$Res> {
  __$$PaymentSuccessImplCopyWithImpl(
      _$PaymentSuccessImpl _value, $Res Function(_$PaymentSuccessImpl) _then)
      : super(_value, _then);
}

/// @nodoc
@JsonSerializable()
class _$PaymentSuccessImpl implements PaymentSuccess {
  const _$PaymentSuccessImpl({final String? $type})
      : $type = $type ?? 'success';

  factory _$PaymentSuccessImpl.fromJson(Map<String, dynamic> json) =>
      _$$PaymentSuccessImplFromJson(json);

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'PaymentState.success()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PaymentSuccessImpl);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() failure,
    required TResult Function() success,
  }) {
    return success();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function()? failure,
    TResult? Function()? success,
  }) {
    return success?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? failure,
    TResult Function()? success,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PaymentInitial value) initial,
    required TResult Function(PaymentLoading value) loading,
    required TResult Function(PaymentFailure value) failure,
    required TResult Function(PaymentSuccess value) success,
  }) {
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PaymentInitial value)? initial,
    TResult? Function(PaymentLoading value)? loading,
    TResult? Function(PaymentFailure value)? failure,
    TResult? Function(PaymentSuccess value)? success,
  }) {
    return success?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PaymentInitial value)? initial,
    TResult Function(PaymentLoading value)? loading,
    TResult Function(PaymentFailure value)? failure,
    TResult Function(PaymentSuccess value)? success,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$PaymentSuccessImplToJson(
      this,
    );
  }
}

abstract class PaymentSuccess implements PaymentState {
  const factory PaymentSuccess() = _$PaymentSuccessImpl;

  factory PaymentSuccess.fromJson(Map<String, dynamic> json) =
      _$PaymentSuccessImpl.fromJson;
}

ResetPinState _$ResetPinStateFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'initial':
      return ResetPinStateInitial.fromJson(json);
    case 'loading':
      return ResetPinStateLoading.fromJson(json);
    case 'failure':
      return ResetPinStateFailure.fromJson(json);
    case 'success':
      return ResetPinStateSuccess.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'ResetPinState',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$ResetPinState {
  bool get disabled => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(bool disabled) initial,
    required TResult Function(bool disabled) loading,
    required TResult Function(bool disabled) failure,
    required TResult Function(bool disabled) success,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(bool disabled)? initial,
    TResult? Function(bool disabled)? loading,
    TResult? Function(bool disabled)? failure,
    TResult? Function(bool disabled)? success,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(bool disabled)? initial,
    TResult Function(bool disabled)? loading,
    TResult Function(bool disabled)? failure,
    TResult Function(bool disabled)? success,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ResetPinStateInitial value) initial,
    required TResult Function(ResetPinStateLoading value) loading,
    required TResult Function(ResetPinStateFailure value) failure,
    required TResult Function(ResetPinStateSuccess value) success,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ResetPinStateInitial value)? initial,
    TResult? Function(ResetPinStateLoading value)? loading,
    TResult? Function(ResetPinStateFailure value)? failure,
    TResult? Function(ResetPinStateSuccess value)? success,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ResetPinStateInitial value)? initial,
    TResult Function(ResetPinStateLoading value)? loading,
    TResult Function(ResetPinStateFailure value)? failure,
    TResult Function(ResetPinStateSuccess value)? success,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ResetPinStateCopyWith<ResetPinState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ResetPinStateCopyWith<$Res> {
  factory $ResetPinStateCopyWith(
          ResetPinState value, $Res Function(ResetPinState) then) =
      _$ResetPinStateCopyWithImpl<$Res, ResetPinState>;
  @useResult
  $Res call({bool disabled});
}

/// @nodoc
class _$ResetPinStateCopyWithImpl<$Res, $Val extends ResetPinState>
    implements $ResetPinStateCopyWith<$Res> {
  _$ResetPinStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? disabled = null,
  }) {
    return _then(_value.copyWith(
      disabled: null == disabled
          ? _value.disabled
          : disabled // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ResetPinStateInitialImplCopyWith<$Res>
    implements $ResetPinStateCopyWith<$Res> {
  factory _$$ResetPinStateInitialImplCopyWith(_$ResetPinStateInitialImpl value,
          $Res Function(_$ResetPinStateInitialImpl) then) =
      __$$ResetPinStateInitialImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({bool disabled});
}

/// @nodoc
class __$$ResetPinStateInitialImplCopyWithImpl<$Res>
    extends _$ResetPinStateCopyWithImpl<$Res, _$ResetPinStateInitialImpl>
    implements _$$ResetPinStateInitialImplCopyWith<$Res> {
  __$$ResetPinStateInitialImplCopyWithImpl(_$ResetPinStateInitialImpl _value,
      $Res Function(_$ResetPinStateInitialImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? disabled = null,
  }) {
    return _then(_$ResetPinStateInitialImpl(
      null == disabled
          ? _value.disabled
          : disabled // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ResetPinStateInitialImpl implements ResetPinStateInitial {
  const _$ResetPinStateInitialImpl([this.disabled = true, final String? $type])
      : $type = $type ?? 'initial';

  factory _$ResetPinStateInitialImpl.fromJson(Map<String, dynamic> json) =>
      _$$ResetPinStateInitialImplFromJson(json);

  @override
  @JsonKey()
  final bool disabled;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ResetPinState.initial(disabled: $disabled)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ResetPinStateInitialImpl &&
            (identical(other.disabled, disabled) ||
                other.disabled == disabled));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, disabled);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ResetPinStateInitialImplCopyWith<_$ResetPinStateInitialImpl>
      get copyWith =>
          __$$ResetPinStateInitialImplCopyWithImpl<_$ResetPinStateInitialImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(bool disabled) initial,
    required TResult Function(bool disabled) loading,
    required TResult Function(bool disabled) failure,
    required TResult Function(bool disabled) success,
  }) {
    return initial(disabled);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(bool disabled)? initial,
    TResult? Function(bool disabled)? loading,
    TResult? Function(bool disabled)? failure,
    TResult? Function(bool disabled)? success,
  }) {
    return initial?.call(disabled);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(bool disabled)? initial,
    TResult Function(bool disabled)? loading,
    TResult Function(bool disabled)? failure,
    TResult Function(bool disabled)? success,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(disabled);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ResetPinStateInitial value) initial,
    required TResult Function(ResetPinStateLoading value) loading,
    required TResult Function(ResetPinStateFailure value) failure,
    required TResult Function(ResetPinStateSuccess value) success,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ResetPinStateInitial value)? initial,
    TResult? Function(ResetPinStateLoading value)? loading,
    TResult? Function(ResetPinStateFailure value)? failure,
    TResult? Function(ResetPinStateSuccess value)? success,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ResetPinStateInitial value)? initial,
    TResult Function(ResetPinStateLoading value)? loading,
    TResult Function(ResetPinStateFailure value)? failure,
    TResult Function(ResetPinStateSuccess value)? success,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ResetPinStateInitialImplToJson(
      this,
    );
  }
}

abstract class ResetPinStateInitial implements ResetPinState {
  const factory ResetPinStateInitial([final bool disabled]) =
      _$ResetPinStateInitialImpl;

  factory ResetPinStateInitial.fromJson(Map<String, dynamic> json) =
      _$ResetPinStateInitialImpl.fromJson;

  @override
  bool get disabled;
  @override
  @JsonKey(ignore: true)
  _$$ResetPinStateInitialImplCopyWith<_$ResetPinStateInitialImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ResetPinStateLoadingImplCopyWith<$Res>
    implements $ResetPinStateCopyWith<$Res> {
  factory _$$ResetPinStateLoadingImplCopyWith(_$ResetPinStateLoadingImpl value,
          $Res Function(_$ResetPinStateLoadingImpl) then) =
      __$$ResetPinStateLoadingImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({bool disabled});
}

/// @nodoc
class __$$ResetPinStateLoadingImplCopyWithImpl<$Res>
    extends _$ResetPinStateCopyWithImpl<$Res, _$ResetPinStateLoadingImpl>
    implements _$$ResetPinStateLoadingImplCopyWith<$Res> {
  __$$ResetPinStateLoadingImplCopyWithImpl(_$ResetPinStateLoadingImpl _value,
      $Res Function(_$ResetPinStateLoadingImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? disabled = null,
  }) {
    return _then(_$ResetPinStateLoadingImpl(
      null == disabled
          ? _value.disabled
          : disabled // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ResetPinStateLoadingImpl implements ResetPinStateLoading {
  const _$ResetPinStateLoadingImpl([this.disabled = true, final String? $type])
      : $type = $type ?? 'loading';

  factory _$ResetPinStateLoadingImpl.fromJson(Map<String, dynamic> json) =>
      _$$ResetPinStateLoadingImplFromJson(json);

  @override
  @JsonKey()
  final bool disabled;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ResetPinState.loading(disabled: $disabled)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ResetPinStateLoadingImpl &&
            (identical(other.disabled, disabled) ||
                other.disabled == disabled));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, disabled);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ResetPinStateLoadingImplCopyWith<_$ResetPinStateLoadingImpl>
      get copyWith =>
          __$$ResetPinStateLoadingImplCopyWithImpl<_$ResetPinStateLoadingImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(bool disabled) initial,
    required TResult Function(bool disabled) loading,
    required TResult Function(bool disabled) failure,
    required TResult Function(bool disabled) success,
  }) {
    return loading(disabled);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(bool disabled)? initial,
    TResult? Function(bool disabled)? loading,
    TResult? Function(bool disabled)? failure,
    TResult? Function(bool disabled)? success,
  }) {
    return loading?.call(disabled);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(bool disabled)? initial,
    TResult Function(bool disabled)? loading,
    TResult Function(bool disabled)? failure,
    TResult Function(bool disabled)? success,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(disabled);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ResetPinStateInitial value) initial,
    required TResult Function(ResetPinStateLoading value) loading,
    required TResult Function(ResetPinStateFailure value) failure,
    required TResult Function(ResetPinStateSuccess value) success,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ResetPinStateInitial value)? initial,
    TResult? Function(ResetPinStateLoading value)? loading,
    TResult? Function(ResetPinStateFailure value)? failure,
    TResult? Function(ResetPinStateSuccess value)? success,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ResetPinStateInitial value)? initial,
    TResult Function(ResetPinStateLoading value)? loading,
    TResult Function(ResetPinStateFailure value)? failure,
    TResult Function(ResetPinStateSuccess value)? success,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ResetPinStateLoadingImplToJson(
      this,
    );
  }
}

abstract class ResetPinStateLoading implements ResetPinState {
  const factory ResetPinStateLoading([final bool disabled]) =
      _$ResetPinStateLoadingImpl;

  factory ResetPinStateLoading.fromJson(Map<String, dynamic> json) =
      _$ResetPinStateLoadingImpl.fromJson;

  @override
  bool get disabled;
  @override
  @JsonKey(ignore: true)
  _$$ResetPinStateLoadingImplCopyWith<_$ResetPinStateLoadingImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ResetPinStateFailureImplCopyWith<$Res>
    implements $ResetPinStateCopyWith<$Res> {
  factory _$$ResetPinStateFailureImplCopyWith(_$ResetPinStateFailureImpl value,
          $Res Function(_$ResetPinStateFailureImpl) then) =
      __$$ResetPinStateFailureImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({bool disabled});
}

/// @nodoc
class __$$ResetPinStateFailureImplCopyWithImpl<$Res>
    extends _$ResetPinStateCopyWithImpl<$Res, _$ResetPinStateFailureImpl>
    implements _$$ResetPinStateFailureImplCopyWith<$Res> {
  __$$ResetPinStateFailureImplCopyWithImpl(_$ResetPinStateFailureImpl _value,
      $Res Function(_$ResetPinStateFailureImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? disabled = null,
  }) {
    return _then(_$ResetPinStateFailureImpl(
      null == disabled
          ? _value.disabled
          : disabled // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ResetPinStateFailureImpl implements ResetPinStateFailure {
  const _$ResetPinStateFailureImpl([this.disabled = false, final String? $type])
      : $type = $type ?? 'failure';

  factory _$ResetPinStateFailureImpl.fromJson(Map<String, dynamic> json) =>
      _$$ResetPinStateFailureImplFromJson(json);

  @override
  @JsonKey()
  final bool disabled;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ResetPinState.failure(disabled: $disabled)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ResetPinStateFailureImpl &&
            (identical(other.disabled, disabled) ||
                other.disabled == disabled));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, disabled);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ResetPinStateFailureImplCopyWith<_$ResetPinStateFailureImpl>
      get copyWith =>
          __$$ResetPinStateFailureImplCopyWithImpl<_$ResetPinStateFailureImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(bool disabled) initial,
    required TResult Function(bool disabled) loading,
    required TResult Function(bool disabled) failure,
    required TResult Function(bool disabled) success,
  }) {
    return failure(disabled);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(bool disabled)? initial,
    TResult? Function(bool disabled)? loading,
    TResult? Function(bool disabled)? failure,
    TResult? Function(bool disabled)? success,
  }) {
    return failure?.call(disabled);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(bool disabled)? initial,
    TResult Function(bool disabled)? loading,
    TResult Function(bool disabled)? failure,
    TResult Function(bool disabled)? success,
    required TResult orElse(),
  }) {
    if (failure != null) {
      return failure(disabled);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ResetPinStateInitial value) initial,
    required TResult Function(ResetPinStateLoading value) loading,
    required TResult Function(ResetPinStateFailure value) failure,
    required TResult Function(ResetPinStateSuccess value) success,
  }) {
    return failure(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ResetPinStateInitial value)? initial,
    TResult? Function(ResetPinStateLoading value)? loading,
    TResult? Function(ResetPinStateFailure value)? failure,
    TResult? Function(ResetPinStateSuccess value)? success,
  }) {
    return failure?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ResetPinStateInitial value)? initial,
    TResult Function(ResetPinStateLoading value)? loading,
    TResult Function(ResetPinStateFailure value)? failure,
    TResult Function(ResetPinStateSuccess value)? success,
    required TResult orElse(),
  }) {
    if (failure != null) {
      return failure(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ResetPinStateFailureImplToJson(
      this,
    );
  }
}

abstract class ResetPinStateFailure implements ResetPinState {
  const factory ResetPinStateFailure([final bool disabled]) =
      _$ResetPinStateFailureImpl;

  factory ResetPinStateFailure.fromJson(Map<String, dynamic> json) =
      _$ResetPinStateFailureImpl.fromJson;

  @override
  bool get disabled;
  @override
  @JsonKey(ignore: true)
  _$$ResetPinStateFailureImplCopyWith<_$ResetPinStateFailureImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ResetPinStateSuccessImplCopyWith<$Res>
    implements $ResetPinStateCopyWith<$Res> {
  factory _$$ResetPinStateSuccessImplCopyWith(_$ResetPinStateSuccessImpl value,
          $Res Function(_$ResetPinStateSuccessImpl) then) =
      __$$ResetPinStateSuccessImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({bool disabled});
}

/// @nodoc
class __$$ResetPinStateSuccessImplCopyWithImpl<$Res>
    extends _$ResetPinStateCopyWithImpl<$Res, _$ResetPinStateSuccessImpl>
    implements _$$ResetPinStateSuccessImplCopyWith<$Res> {
  __$$ResetPinStateSuccessImplCopyWithImpl(_$ResetPinStateSuccessImpl _value,
      $Res Function(_$ResetPinStateSuccessImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? disabled = null,
  }) {
    return _then(_$ResetPinStateSuccessImpl(
      null == disabled
          ? _value.disabled
          : disabled // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ResetPinStateSuccessImpl implements ResetPinStateSuccess {
  const _$ResetPinStateSuccessImpl([this.disabled = false, final String? $type])
      : $type = $type ?? 'success';

  factory _$ResetPinStateSuccessImpl.fromJson(Map<String, dynamic> json) =>
      _$$ResetPinStateSuccessImplFromJson(json);

  @override
  @JsonKey()
  final bool disabled;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ResetPinState.success(disabled: $disabled)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ResetPinStateSuccessImpl &&
            (identical(other.disabled, disabled) ||
                other.disabled == disabled));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, disabled);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ResetPinStateSuccessImplCopyWith<_$ResetPinStateSuccessImpl>
      get copyWith =>
          __$$ResetPinStateSuccessImplCopyWithImpl<_$ResetPinStateSuccessImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(bool disabled) initial,
    required TResult Function(bool disabled) loading,
    required TResult Function(bool disabled) failure,
    required TResult Function(bool disabled) success,
  }) {
    return success(disabled);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(bool disabled)? initial,
    TResult? Function(bool disabled)? loading,
    TResult? Function(bool disabled)? failure,
    TResult? Function(bool disabled)? success,
  }) {
    return success?.call(disabled);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(bool disabled)? initial,
    TResult Function(bool disabled)? loading,
    TResult Function(bool disabled)? failure,
    TResult Function(bool disabled)? success,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(disabled);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ResetPinStateInitial value) initial,
    required TResult Function(ResetPinStateLoading value) loading,
    required TResult Function(ResetPinStateFailure value) failure,
    required TResult Function(ResetPinStateSuccess value) success,
  }) {
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ResetPinStateInitial value)? initial,
    TResult? Function(ResetPinStateLoading value)? loading,
    TResult? Function(ResetPinStateFailure value)? failure,
    TResult? Function(ResetPinStateSuccess value)? success,
  }) {
    return success?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ResetPinStateInitial value)? initial,
    TResult Function(ResetPinStateLoading value)? loading,
    TResult Function(ResetPinStateFailure value)? failure,
    TResult Function(ResetPinStateSuccess value)? success,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ResetPinStateSuccessImplToJson(
      this,
    );
  }
}

abstract class ResetPinStateSuccess implements ResetPinState {
  const factory ResetPinStateSuccess([final bool disabled]) =
      _$ResetPinStateSuccessImpl;

  factory ResetPinStateSuccess.fromJson(Map<String, dynamic> json) =
      _$ResetPinStateSuccessImpl.fromJson;

  @override
  bool get disabled;
  @override
  @JsonKey(ignore: true)
  _$$ResetPinStateSuccessImplCopyWith<_$ResetPinStateSuccessImpl>
      get copyWith => throw _privateConstructorUsedError;
}
